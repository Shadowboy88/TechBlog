<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Postgre SQL Optimization</title>
      <link href="/TechBlog/2021/09/03/Postgre-SQL-Optimization/"/>
      <url>/TechBlog/2021/09/03/Postgre-SQL-Optimization/</url>
      
        <content type="html"><![CDATA[<h1 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h1><p>当查询接口数据量过大，接口响应时间过长的情况下，应当考虑优化sql查询耗时。这种情况下可以考虑适当添加索引，<br>优化查询速度。本文以postgre sql为例，聊聊sql查询优化的案例。</p><h1 id="1-sql执行计划"><a href="#1-sql执行计划" class="headerlink" title="1. sql执行计划"></a>1. sql执行计划</h1><p> 在分析sql执行耗时的过程中需要用到sql执行计划来辅助分析sql执行的步骤和每一步的耗时。<br> sql执行计划就相当于程序执行的日志。</p><h2 id="1-1-基本语法"><a href="#1-1-基本语法" class="headerlink" title="1.1 基本语法"></a>1.1 基本语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN [ ANALYZE ] [ VERBOSE ] sql语句</span><br></pre></td></tr></table></figure><p>各参数含义：</p><p>analyze：执行语句并显示真正的运行时间和其它统计信息，会真正执行SQL语句,比较常用；</p><p>verbose：显示额外的信息,尤其是计划树中每个节点的字段列表,schema识别表和函数名称。总是打印统计数据中显示的每个触发器的名字；</p><p>costs：包括每个计划节点的启动成本预估和总成本的消耗，也包括行数和行宽度的预估；</p><p>buffers：使用信息，特别包括共享块命中、读、脏和写的次数，本地块命中、读、脏和写，临时块读和写的次数；</p><p>timing：在输出中包含实际启动时间和每个节点花费的时间，重复读系统块在某些系统上会显著的减缓查询的速度，只在ANALYZE也启用的时候使用；</p><p>format：声明输出格式，可以为TEXT, XML, JSON 或 YAML，默认text；</p><h2 id="1-2-基本输出"><a href="#1-2-基本输出" class="headerlink" title="1.2 基本输出"></a>1.2 基本输出</h2><p>命令的结果是从statement选择的规划的文字描述， 可选的有执行统计数据的注释。如果你想提供EXPLAIN输出给程序用作进一步分析， 你应该使用它的机器可读的输出格式之一(XML, JSON, or YAML)来代替。</p><p>查询规划的结构是一个规划节点的树。最底层的节点是表扫描节点： 它们从表中返回原始数据行。不同的表访问模式有不同的扫描节点类型： 顺序扫描（Full scan|Seq scan）、索引扫描(Index scan)、位图索引扫描(Bit index scan)。<br>也有非表行来源，如VALUES子句和FROM中返回行集的函数， 它们有自己的扫描节点类型。 如果查询需要连接、聚合、排序、或者对原始行的其它操作， 那么就会在扫描节点之上有其它额外的节点。并且，做这些操作通常都有多种方法，<br>因此在这些位置也有可能出现不同的节点类型。EXPLAIN给规划树中每个节点都输出一行， 显示基本的节点类型和规划器为执行这个规划节点预计的开销值。 可能会出现附加的行，这些行从节点的汇总行缩进，显示这个节点的额外属性。<br>第一行(最上层的汇总行节点)是对该规划的总执行开销的预计；这个数值就是规划器试图最小化的数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tenk1;</span><br><span class="line"></span><br><span class="line">                         QUERY PLAN</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"> Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)</span><br></pre></td></tr></table></figure><p>上述举例中即为顺序扫描。由于此查询没有WHERE子句，它必须扫描所有表的行，所以规划器已经选择使用一个简单的顺序扫描计划。 括号中引用的数值是（从左到右）:</p><ul><li><p>预计的启动开销。在输出扫描开始之前消耗的时间，比如在一个排序节点里执行排序的时间。</p></li><li><p>预计总开销。这个估算是假设计划节点运行完成做出的，即所有可用行都被检索。 在实际中一个节点的父节点可能会决定不读取所有可用的行（参见LIMIT下面的例子）。</p></li><li><p>预计这个规划节点输出的行数。同样，这个节点被假定执行到完成为止。</p></li><li><p>预计这个规划节点的行平均宽度(以字节计算)。</p><h1 id="2-Postgre-SQL索引"><a href="#2-Postgre-SQL索引" class="headerlink" title="2 Postgre SQL索引"></a>2 Postgre SQL索引</h1><p>PgSql索引和Mysql索引类似，需要手动创建和维护。</p><h2 id="2-1-创建索引"><a href="#2-1-创建索引" class="headerlink" title="2.1 创建索引"></a>2.1 创建索引</h2><p>CREATE INDEX （创建索引）的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3></li><li><p>单列索引</p><p>单列索引是一个只基于表的一个列上创建的索引，基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">ON table_name (column_name);</span><br></pre></td></tr></table></figure></li><li><p>组合索引</p></li></ul><p>组合索引是基于表的多列上创建的索引，基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">ON table_name (column1_name, column2_name);</span><br></pre></td></tr></table></figure><ul><li>唯一索引</li></ul><p>使用唯一索引不仅是为了性能，同时也为了数据的完整性。唯一索引不允许任何重复的值插入到表中。基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name</span><br><span class="line">on table_name (column_name);</span><br></pre></td></tr></table></figure><ul><li>局部索引</li></ul><p>局部索引 是在表的子集上构建的索引；子集由一个条件表达式上定义。索引只包含满足条件的行。基础语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">on table_name (conditional_expression);</span><br></pre></td></tr></table></figure><h2 id="2-2-删除索引"><a href="#2-2-删除索引" class="headerlink" title="2.2 删除索引"></a>2.2 删除索引</h2><p>一个索引可以使用 PostgreSQL 的 DROP 命令删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name;</span><br></pre></td></tr></table></figure><h2 id="2-3-查看索引"><a href="#2-3-查看索引" class="headerlink" title="2.3 查看索引"></a>2.3 查看索引</h2><p>已经创建的索引可以通过以下命令查询：</p><figure class="highlight plaintext"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">A.SCHEMANAME,</span><br><span class="line">A.TABLENAME,</span><br><span class="line">A.INDEXNAME,</span><br><span class="line">A.TABLESPACE,</span><br><span class="line">A.INDEXDEF,</span><br><span class="line">B.AMNAME,</span><br><span class="line">C.INDEXRELID,</span><br><span class="line">C.INDNATTS,</span><br><span class="line">C.INDISUNIQUE,</span><br><span class="line">C.INDISPRIMARY,</span><br><span class="line">C.INDISCLUSTERED,</span><br><span class="line">D.DESCRIPTION</span><br><span class="line">from</span><br><span class="line">PG_AM B left join PG_CLASS F on</span><br><span class="line">B.OID = F.RELAM left join PG_STAT_ALL_INDEXES E on</span><br><span class="line">F.OID = E.INDEXRELID left join PG_INDEX C on</span><br><span class="line">E.INDEXRELID = C.INDEXRELID left outer join PG_DESCRIPTION D on</span><br><span class="line">C.INDEXRELID = D.OBJOID,</span><br><span class="line">PG_INDEXES A</span><br><span class="line">where</span><br><span class="line">A.SCHEMANAME = E.SCHEMANAME</span><br><span class="line">and A.TABLENAME = E.RELNAME</span><br><span class="line">and A.INDEXNAME = E.INDEXRELNAME</span><br><span class="line">and E.SCHEMANAME = &#x27;public&#x27;</span><br><span class="line">and E.RELNAME = &#x27;tableName&#x27;;</span><br></pre></td></tr></table></figure><h1 id="3-索引失效"><a href="#3-索引失效" class="headerlink" title="3. 索引失效"></a>3. 索引失效</h1><p>如果where过滤条件设置不合理，即使索引存在，且where过滤条件中包含索引列，也会导致全表扫描，索引不起作用。<br>以下几种场景会导致索引失效：</p><ul><li>任何计算、函数、类型转换</li><li>!=</li><li>NOT，相当于使用函数</li><li>模糊查询通配符在开头</li><li>索引字段在表中占比较高</li><li>多字段btree索引查询条件不包含第一列 </li><li>多字段索引查询条件使用OR（有时也会走索引扫描，但查询效率不高）</li><li><font color=red face="黑体">如果SELECT返回大约超过表中所有行的5-10%，则顺序扫描要比索引扫描快得多。</font></li></ul><p>本次主要分析最后一种情况。我花费了半天才搞懂这情况。</p><h3 id="1-分析执行计划"><a href="#1-分析执行计划" class="headerlink" title="1. 分析执行计划"></a>1. 分析执行计划</h3><figure class="highlight plaintext"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Sort  (cost=42520.16..42520.39 rows=92 width=45) (actual time=181.770..181.780 rows=72 loops=1)</span><br><span class="line">Sort Key: con.id</span><br><span class="line">Sort Method: quicksort  Memory: 32kB</span><br><span class="line">        -&gt;  HashAggregate  (cost=42515.32..42517.16 rows=92 width=45) (actual time=181.559..181.681 rows=72 loops=1)</span><br><span class="line">&quot;        Group Key: con.id, con.feature_name, con.attr_name, con.attr_value&quot;</span><br><span class="line">-&gt;  Hash Join  (cost=4349.22..42413.72 rows=6773 width=45) (actual time=117.748..177.320 rows=2460 loops=1)</span><br><span class="line">Hash Cond: ((s.feature_id = con.feature_id) AND ((s.attr_name)::text = (con.attr_name)::text))</span><br><span class="line">Join Filter: ((con.attr_value IS NULL) OR ((s.attr_value)::text = (con.attr_value)::text))</span><br><span class="line">Rows Removed by Join Filter: 410</span><br><span class="line">-&gt;  Bitmap Heap Scan on stats_result s  (cost=4311.10..39553.18 rows=67106 width=43) (actual time=117.118..172.912 rows=4435 loops=1)</span><br><span class="line">Recheck Cond: (data_version_id = 149)</span><br><span class="line">        &quot;                    Filter: (&quot;&quot;position&quot;&quot;((admin)::text, &#x27;21009408&#x27;::text) &gt; 0)&quot;</span><br><span class="line">Rows Removed by Filter: 193518</span><br><span class="line">Heap Blocks: exact=1580</span><br><span class="line">-&gt;  Bitmap Index Scan on version_feature_idx  (cost=0.00..4294.32 rows=201319 width=0) (actual time=32.292..32.292 rows=197953 loops=1)</span><br><span class="line">Index Cond: (data_version_id = 149)</span><br><span class="line">        -&gt;  Hash  (cost=36.75..36.75 rows=92 width=37) (actual time=0.593..0.593 rows=92 loops=1)</span><br><span class="line">Buckets: 1024  Batches: 1  Memory Usage: 7kB</span><br><span class="line">        -&gt;  Subquery Scan on con  (cost=35.60..36.75 rows=92 width=37) (actual time=0.454..0.504 rows=92 loops=1)</span><br><span class="line">-&gt;  Sort  (cost=35.60..35.83 rows=92 width=37) (actual time=0.453..0.463 rows=92 loops=1)</span><br><span class="line">Sort Key: u.id</span><br><span class="line">Sort Method: quicksort  Memory: 33kB</span><br><span class="line">        -&gt;  Hash Join  (cost=22.42..32.59 rows=92 width=37) (actual time=0.261..0.366 rows=92 loops=1)</span><br><span class="line">Hash Cond: (u.feature_id = f.id)</span><br><span class="line">-&gt;  Seq Scan on usage_info u  (cost=0.00..8.91 rows=92 width=25) (actual time=0.125..0.172 rows=92 loops=1)</span><br><span class="line">Filter: (view_id = 7)</span><br><span class="line">Rows Removed by Filter: 302</span><br><span class="line">-&gt;  Hash  (cost=21.63..21.63 rows=63 width=20) (actual time=0.115..0.115 rows=63 loops=1)</span><br><span class="line">Buckets: 1024  Batches: 1  Memory Usage: 4kB</span><br><span class="line">        -&gt;  Seq Scan on feature_info f  (cost=0.00..21.63 rows=63 width=20) (actual time=0.006..0.076 rows=63 loops=1)</span><br><span class="line">Planning time: 1.097 ms</span><br><span class="line">Execution time: 181.969 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分析这个执行计划可以看出 sql连表查询了三张表（feature_info，usage_info，stats_result），前两张表都是顺序扫描，最后一张表用上了位图索引和位图复合索引没有问题。<br>查看feature_info和usage_info两张的索引：</p><table><thead><tr><th>schemaname</th><th>tablename</th><th>indexname</th><th>tablespace</th><th>indexdef</th><th>amname</th><th>indexrelid</th><th>indnatts</th><th>indisunique</th><th>indisprimary</th></tr></thead><tbody><tr><td>public</td><td>usage_info</td><td>usage_info_pkey</td><td>CREATE UNIQUE INDEX usage_info_pkey ON usage_info USING btree (id)</td><td>btree</td><td>27066381</td><td>1</td><td>TRUE</td><td>TRUE</td><td>FALSE</td></tr><tr><td>public</td><td>usage_info</td><td>view_id_index</td><td>CREATE INDEX view_id_index ON usage_info USING btree (view_id)</td><td>btree</td><td>28196880</td><td>1</td><td>FALSE</td><td>FALSE</td><td>FALSE</td></tr></tbody></table><hr><table><thead><tr><th>schemaname</th><th>tablename</th><th>indexname</th><th>tablespace</th><th>indexdef</th><th>amname</th><th>indexrelid</th><th>indnatts</th><th>indisunique</th><th>indisprimary</th><th>indisclustered</th><th>description</th></tr></thead><tbody><tr><td>public</td><td>feature_info</td><td>feature_info_pkey</td><td></td><td>CREATE UNIQUE INDEX feature_info_pkey ON feature_info USING btree (id)</td><td>btree</td><td>27066289</td><td>1</td><td>true</td><td>true</td><td>false</td><td></td></tr></tbody></table><p>测试usage_info这张表索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain analyse select * from usage_info where view_id = 7;</span><br></pre></td></tr></table></figure><p>执行计划：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Seq Scan on usage_info  (cost=0.00..8.91 rows=92 width=65) (actual time=0.124..0.161 rows=92 loops=1)</span><br><span class="line">  Filter: (view_id = 7)</span><br><span class="line">  Rows Removed by Filter: 302</span><br><span class="line">Planning time: 0.303 ms</span><br><span class="line">Execution time: 0.210 ms</span><br></pre></td></tr></table></figure><p>发现是顺序扫描，查询结果92条记录。<br>测试主键索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain analyse select * from usage_info where id = 7;</span><br></pre></td></tr></table></figure><p>执行计划：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Index Scan using usage_info_pkey on usage_info  (cost=0.15..8.17 rows=1 width=65) (actual time=0.017..0.019 rows=1 loops=1)</span><br><span class="line">  Index Cond: (id = 7)</span><br><span class="line">Planning time: 0.104 ms</span><br><span class="line">Execution time: 0.053 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果是索引生效。</p><p>怀疑是表数据变化索引失效，所以把view_id字段索引删除，重新创建。结果依然是顺序索引，很崩溃。。。</p><p>查看PostgreSQL官方文档得出结论：<font color=red face="黑体">如果SELECT返回大约超过表中所有行的5-10%，则顺序扫描要比索引扫描快得多。</font></p><p>验证：<br>在usage_info新插入一条view_id= 8的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain analyse select * from usage_info where id = 8;</span><br></pre></td></tr></table></figure><p>果然：</p><figure class="highlight plaintext"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Index Scan using usage_info_pkey on usage_info  (cost=0.15..8.17 rows=1 width=65) (actual time=0.030..0.034 rows=1 loops=1)</span><br><span class="line">  Index Cond: (id = 8)</span><br><span class="line">Planning time: 0.147 ms</span><br><span class="line">Execution time: 0.081 ms</span><br></pre></td></tr></table></figure><p>查询view_id = 7时，结果row:92,整张表数据row:394。92/394 = 23%,此时seq scan 效率更高。</p><p>数据分布较小(比如 1.7%)，则用 bitmap index scan。数据更少的时候，用的是 index scan。</p><p>需要引起注意的是， bitmap index 也可以用在where 条件单一的时候。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10搭建hadoop开发环境</title>
      <link href="/TechBlog/2021/07/26/hadoop/"/>
      <url>/TechBlog/2021/07/26/hadoop/</url>
      
        <content type="html"><![CDATA[<p>###1.环境准备<br>下载安装JDK8 window版本：<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html#license-lightbox">jdk-8u241-windows-x64.exe</a></p><p>安装、配置jdk环境变量。</p><p>###2.下载hadoop<br>hadoop下载链接：<a href="https://hadoop.apache.org/release/3.1.0.html">hadoop-3.1.0</a><br>下载winutils，Windows安装hadoop需要这部分文件，链接：<a href="https://github.com/steveloughran/winutils">steveloughran/winutils</a> ，找到3.0版本，或者cdarlint/winutils 找到 3.2.0，下载bin目录的文件，放入/替换 C:\hadoop\bin 文件夹内的文件，特别是要放入hadoop.dll和winutils.exe文件，并复制一份hadoop.dll放到C:\Windows\System32下。</p><p>配置hadoop环境变量，把C:\hadoop添加到HADOOP_HOME，并在Path添加 %HADOOP_HOME%\bin 和 %HADOOP_HOME%\sbin 。</p><p>打开CMD，输入hadoop version 测试是否正常显示版本信息。</p><p>###3.配置hadoop</p><p>切换到hadoop安装路径下。</p><p>####3.1修改core-site.xml</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Postgre SQL</title>
      <link href="/TechBlog/2021/07/13/postgre-sql/"/>
      <url>/TechBlog/2021/07/13/postgre-sql/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>PostgreSQL 是一个免费的<strong>对象-关系数据库</strong>服务器(ORDBMS)，在灵活的BSD许可证下发行。</p><p>PostgreSQL 开发者把它念作 post-gress-Q-L。</p><p>PostgreSQL 的 Slogan 是 “世界上最先进的开源关系型数据库”。</p><p>目前，由于MySql被Oracle公司收购，MySql后续可能也会被迫商业化，就用户量来说MySql和Oracle都呈现下降趋势，反而PostgreSql正在稳步上升。<br><a href="https://db-engines.com/en/ranking">参考数据库排名网站</a></p><h1 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h1><h2 id="Ubuntu-安装-PostgreSQL"><a href="#Ubuntu-安装-PostgreSQL" class="headerlink" title="Ubuntu 安装 PostgreSQL"></a>Ubuntu 安装 PostgreSQL</h2><p>Ubuntu 可以使用 apt-get 安装 PostgreSQL：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install postgresql postgresql-client</span><br></pre></td></tr></table></figure><p>安装完毕后，系统会创建一个数据库超级用户 postgres，密码为空。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -i -u postgres</span><br></pre></td></tr></table></figure><p>这时使用以下命令进入 postgres，输出以下信息，说明安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~$ psql</span><br><span class="line">psql (9.5.17)</span><br><span class="line">Type <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>输入以下命令退出 PostgreSQL 提示符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure><p>PostgreSQL 安装完成后默认是已经启动的，但是也可以通过下面的方式来手动启动服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/postgresql start   <span class="comment"># 开启</span></span><br><span class="line">sudo /etc/init.d/postgresql stop    <span class="comment"># 关闭</span></span><br><span class="line">sudo /etc/init.d/postgresql restart <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure><p>#Base Operation</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ sudo su postgres</span><br><span class="line">$ createdb marsblog</span><br><span class="line">$ psql -l </span><br><span class="line">$ psql marsblog</span><br><span class="line">&gt; create table posts(title varchar(255),content text);</span><br><span class="line">&gt; \dt</span><br><span class="line">&gt; \d posts</span><br><span class="line">&gt; alert table posts rename to marsposts;</span><br><span class="line">&gt; \dt</span><br><span class="line">&gt; drop table marsposts;</span><br><span class="line">&gt;\dt</span><br><span class="line">&gt;\q</span><br><span class="line">&gt;nano db.sql</span><br></pre></td></tr></table></figure><h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><ul><li>数值型<ul><li>integer</li><li>real</li><li>serial</li></ul></li><li>文字型<ul><li>char</li><li>varchar</li><li>text</li></ul></li><li>布尔型<ul><li>boolean</li></ul></li><li>日期型   </li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Postgre SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Build Blog Via Hexo</title>
      <link href="/TechBlog/2021/07/13/hello-world/"/>
      <url>/TechBlog/2021/07/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
